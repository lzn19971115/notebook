[TOC]
## 一、数据类型
### 1. 基础数据类型
    byte char short int long float double boolean
    由低到高可隐士转换，即 long a = 1;，向下则需要强转
### 2. 引用类型
    指向对象
### 3. 封装基础数据类型
    Byte Character Short Integer Long Float Double Boolean
    封装类都被关键字final修饰
#### 封装类和基础数据类型的区别
    封装类可以作为对象，基础数据类型不行
## 二、面向对象
### 1. 三大特征
#### 1）封装
    内部成员私有化，只对外提供访问接口
#### 2）继承
    继承父类，具备父类的变量和方法
#### 3）多态
* 概述
    多态建立在继承的基础上，有继承才会有多态
    定义格式： 父类类型 对象名 = new 子类类型；
* 多态特点
    成员变量，编译运行看左边
    成员方法，编译看左边，运行看右边
* 向上转型，向下转型
    本身就是向上转型，已经向上转型的对象可以强转到子类类型
## 三、抽象类和接口
### 1.抽象类，abstract
    定义：具备抽象方法的类为抽象类，抽象方法只有声明，没有定义，被关键字abstract修饰
#### 注意：
    * 抽象类并不是只有抽象方法
    * 抽象类被子类继承后，必须复写父类的抽象方法，否则子类也为抽象类
    * 抽象类不能创建对象
    * abstract不能和关键字private,static,final或native修饰同一个方法
### 2.接口，interface
    定义：接口，指的是调用别人的成员和方法，是对行为的一种抽象
#### 注意：
    * 接口可以有变量和方法，变量默认被public static final修饰，也只能被此修饰
    * 方法默认被public abstract修饰
    * 接口可以有具体方法实现
## 四、重写和重载
### 1.重写
    在继承的前提下，重新复写父类的方法，返回值、方法名、参数均相同
### 2.重载
    方法名相同，参数类型或数量不同，与返回值无关
## 五、final关键字
    1. 修饰类，为不可继承的类，如String，包装类，Integer
    2. 修饰成员，为常量
    3. 修饰方法，不可被重写
    4. 修饰参数，可以访问，无法修改
## 六、static关键字
    1. 修饰成员
    2. 修饰的成员为类成员，伴随着类加载而生成，存在于对象前
    3. 可直接被类调用，类名.静态成员变量
    4. static修饰的数据是共享数据，对象中的数据是特有数据
    5. 静态方法只能访问静态成员
    6. 静态方法中不能使用this或super关键字
## 七、局部变量，静态变量，成员变量
1. 局部变量
    方法或语句块内部的变量。声明周期为声明位置到方法或代码块执行结束
    必须先声明初始化后才能使用
2. 成员变量
    方法外部，类内部定义的变量。声明周期从属于对象。如果不初始化，会赋予默认值
3. 静态变量
    被static修饰的变量，从属于类，类加载到类卸载
## 八、字符串
1. String
    被final修饰，常量，不可被修改
2. 字符串常量池
    每当代码创建字符串常量时，会先判断常量池之中是否包含，如果已经包含，则将该引用赋予新建常量，否则实例化一个字符串并放到池中，通过new关键字创建的字符串不指向池中的对象
3. StringBuffer和StringBuilder
    这两者可以修改字符串类型
    StringBuffer线程安全
    StringBuilder线程不安全，效率稍快一些
    
## 九、访问修饰符

| 访问修饰符 | 本类 | 同包   | 子类   | 其他位置 |
| ---------- | ---- | ------ | ------ | -------- |
| public     | 可以 | 可以   | 可以   | 可以     |
| protected  | 可以 | 可以   | 可以   | 不可以   |
| 默认       | 可以 | 可以   | 不可以 | 不可以   |
| private    | 可以 | 不可以 | 不可以 | 不可以   |
## 十、java是值传递，还是地址传递
    不管是基础类型，还是引用类型都是值传递，
    基础类型，传递具体的值，相当于赋值，
    引用类型，传递的是具体地址值，修改会修改堆中的值
## 十一、深拷贝和浅拷贝
    深拷贝和浅拷贝主要是针对引用类型，拷贝对于基本类型来说就是赋值，不存在深浅问题。
### 1.定义
    深拷贝：将值复制过来
    浅拷贝：只是将引用的地址复制过来，两者只向同一个对象
### 2.内存
    基本类型：都是存储在栈中，独立的空间,互不影响
   ![基本类型](https://img-blog.csdnimg.cn/20200909100219331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bmRheTk3,size_16,color_FFFFFF,t_70#pic_center)
    引用类型：地址存储在栈中，具体的值存储在堆中
   ![引用类型](https://img-blog.csdnimg.cn/20200909103622491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N1bmRheTk3,size_16,color_FFFFFF,t_70#pic_center) 
## 十二、异常
### 1.概述
    异常机制是指当程序出现错误时，程序如何处理，即异常机制提供了程序安全退出的通道，发生异常时，程序执行流程发生改变，交给异常处理器
### 2.分类
![异常架构](https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70)
### 3.Exception分类
#### 3.1运行时异常
    通常是由程序的逻辑异常造成的，Java编译器不会去检查
* 空指针
* 下标越界
* 非法参数
#### 3.1非运行时异常（编译异常）
    必须进行处理，否则编译不通过，try-catch捕获或者抛出throws两种方式进行处理
## 十三、反射

Java 反射，就是在运行状态中:
* 获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等
* 获取任意对象的属性，并且能改变对象的属性
* 调用任意对象的方法
* 判断任意一个对象所属的类
* 实例化任意一个类的对象